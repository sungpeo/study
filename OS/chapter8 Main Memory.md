# Chapter8. Main Memory

The memory-management algorithms vary from a primitive bare-machine approach to paging and segmentation strategies. Selection of a memory-management method for a specific system depends on many factors, especially on the hardware design of the system.

## Chapter Objectives

메모리 관리 알고리즘은 primitive bare-machine 접근방법에서부터 paging and segmentation 전략까지 다양하다. 시스템을 위한 메모리 관리 선택은 여러 factor의 영향을 받는데, 특별히 하드웨어 시스템 설계에 따른 영향을 받는다.

* To provide a detailed description of various ways of organizing memory hardware
* To explore various techniques of allocating memory to processes.
* To discuss in detail how paging works in contemporary computer systems.

## 8.1 Background

chapter1에서 살펴본 것처럼 메모리는 현대 컴퓨터 시스템의 동작에 주요한 역할을 한다. 메모리는 큰 바이트들의 배열을 가지며, 각각에 대한 주소값을 가지고 있다. CPU는 program counter의 값에 따라 메모리에서 명령(instructions)을 가져온다. 이 명령어들은 특정 메모리 주소에 대한 추가적인 loading과 storing을 발생시킬 수 있다.
예를 들어, 전형적인 instruction-execution 사이클이 메모리로부터 처음 an instruction을 가져왔다. 그 instruction은 디코딩된 후에 또 다른 operands를 메모리로부터 가져오도록 만들 수 있다. 그 instruction이 그 operands까지 수행된 후에 결과는 memory에 다시 저장될 것이다. The memory unit sees only a stream of memory addresses; it does not know how they are generated (by the instruction counter, indexing, indirection,literal addresses, and so on) or what they are for (instructions or data). 따라서 우리는 program이 어떻게 메모리 주소를 만들어내는지는 무시해도 된다. 우리는 오직 수행 중인 프로그램이 메모리 주소를 어떤 순서로 만들어내는 지 관심 있을 뿐이다.
우리는 메모리 관리와 관련된 몇 가지 문제를 다뤄보려고 한다: basic hardware, the binding of symbolic memory addresses to actual physical addresses, and the distinction between logical and physical addresses. 그리고 dynamic linking과 shared libararies에 대해 알아보며 섹션을 마무리할 것이다.

### 8.1.1 Basic Hardware

프로세서에 설치된(built into) 메인 메모리와 레지스터는 CPU가 직접 접근하는 일반 목적의 스토리지일 뿐이다. arguments로써 메모리 주소를 가져오는 기계 명령(machine instructions)은 있으나, disk 주소를 가져오는 것은 없다. 그러므로 수행 중인 명령이든 data건, 반드시 이런 direct-access storage devices들 중에 하나 안에 존재해야 한다.
CPU 내부에 있는 레지스터는 일반적으로 하나의 CPU clock cycle 내에서 접근 가능하다. 대부분의 CPU들은 instruction을 decode할 수 있고, clock tick마다 하나 이상의 operation을 레지스터 위(on register contents)에서 수행할 수 있다. The same cannot be said of main memory, which is accessed via a transaction on the memory bus. memory access를 완료하는 것은 많은 cycle of the CPU clock이 걸릴 수 있다. 이런 경우에 프로세서는 stall (멈춤)이 필요하다. 왜냐하면 프로세서가 수행중인 instruction을 완료시키위에 필요한 data가 없기 때문이다. 이 상황은 메모리 접근의 frequency 때문에 intolerable하다. 해결법은 CPU와 main memory 사이에 fast memory를 추가하는 것이다. 전형적으로 fast access를 위한 CPU chip 위에 위치한다. (cache) CPU에 내장 된 캐시를 관리하기 위해 하드웨어는 운영 체제 제어없이 메모리 액세스 속도를 자동으로 높인다.

각각의 프로세스는  독립된 메모리 공간을 가지며 특정 프로세스만 접근할 수 있는 합법적인(Legal) 메모리 주소 영역을 설정하고, 프로세스가 합법적인 영역만을 접근하도록 하는 것이 필요하다. 이를 기준(Base)과 상한(Limit)이라고 불리는 두 개의 레지스터들을 사용하여 보호 기법을 제공한다.
레지스터로 user mode 에서의 생성된 주소값을 모두 비교하여, 다른 사용자의 memory나 OS memory로의 접근을 fatal error로 처리하여 막는다. 이 구성표(scheme)는 사용자 프로그램이 (실수로 또는 의도적으로) 운영 체제 또는 다른 사용자의 코드 또는 데이터 구조를 수정하는 것을 방지한다.

### 8.1.2 Adress Binding

Usually, a program resides on a disk as a binary executable file. To be executed, the program must be brought into memory and placed within a process. Depending on the memory management in use, the process may be moved between disk and memory during its execution. The processes on the disk that are waiting to be brought into memory for execution form the **input queue**.

In most cases, a user program goes through several steps—some of which may be optional—before being executed (Figure 8.3). Addresses may be represented in different ways during these steps. Addresses in the source program are generally symbolic (such as the variable count). A compiler typically binds these symbolic addresses to relocatable addresses (such as “14 bytes from the beginning of this module”). The linkage editor or loader in turn binds the relocatable addresses to absolute addresses (such as 74014). Each binding is a mapping from one address space to another.

* **Compile time.** 컴파일 타임에 프로세스가 위치할 메모리 주소를 알고 있다면, absolute code가 생성될 것이다. 나중에 starting location이 변하면, 이 코드는 recompile이 필요하다.

* **Load time.** 컴파일 타임에 모른다면 컴파일러는 relocatable code를 생성할 것이다. 이 경우 binding은 load time까지 미뤄진다.

* **Execution time.** 프로세스가 실행 중에 옮겨질 수 있다면, binding은 런타임까지 연기되어야만 한다. 특별한 하드웨어가 이 작업을 위해 필요한데, 8.1.3에서 다룰 것이다. Most general-purpose operating systems use this method.

### 8.1.3 Logical versus Physical Address Space

An address generated by the CPU is commonly referred to as a logical address, whereas an address seen by the memory unit—that is, the one loaded into the memory-address register of the memory—is commonly referred to as a physical address.

#### 논리 주소와 물리 주소

* Logical address – generated by the CPU; also referred to as virtual address
* Physical address – address seen by the memory unit

#### Memory-Management Unit (MMU)

* CPU가 메모리에 접근하는 것을 관리하는 컴퓨터 하드웨어 부품
* 가상 메모리 주소를 실제 메모리 주소로 변환

#### Relocation Register

* In MMU scheme, the value in the relocation register is added to every address generated by a user process at the time it is sent to memory

The user program generates only logical addresses and thinks that the process runs in locations 0 to max. However, these logical addresses must be mapped to physical addresses before they are used.

### 8.1.4 Dynamic Loading

To obtain better memory-space utilization, we can use **dynamic loading**. With dynamic loading, a routine is not loaded until it is called.

The advantage of dynamic loading is that a routine is loaded only when it is needed. This method is particularly useful when large amounts of code are needed to handle infrequently occurring cases, such as error routines. In this case, although the total program size may be large, the portion that is used may be much smaller.

Dynamic loading does not require special support from the operating system. It is the responsibility of the users to design their programs to take advantage of such a method. Operating systems may help the programmer, however, by providing library routines to implement dynamic loading.

### 8.1.5 Dynamic Linking and Shared Libraries

**Dynamically linked libraries** are system libraries that are linked to user programs when the programs are run (refer back to Figure 8.3). Some operating systems support only **static linking**, in which system libraries are treated like any other object module and are combined by the loader into the binary program image.

Here, though, linking, rather than loading, is postponed until execution time. This feature is usually used with system libraries, such as language subroutine libraries.

With dynamic linking, a **stub** is included in the image for each library routine reference. The stub is a small piece of code that indicates how to locate the appropriate memory-resident library routine or how to load the library if the routine is not already present.

Without dynamic linking, all such programs would need to be relinked to gain access to the new library. So that programs will not accidentally execute new, incompatible versions of libraries, version information is included in both the program and the library. Thus, only programs that are compiled with the new library version are affected by any incompatible changes incorporated in it. Other programs linked before the new library was installed will continue using the older library. This system is also known as shared libraries.

Unlike dynamic loading, dynamic linking and shared libraries generally require help from the operating system. If the processes in memory are protected from one another, then the operating system is the only entity that can check to see whether the needed routine is in another process’s memory space or that can allow multiple processes to access the same memory addresses. We elaborate on this concept when we discuss paging in Section 8.5.4.

